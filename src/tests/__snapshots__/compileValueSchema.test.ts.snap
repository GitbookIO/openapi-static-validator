// Bun Snapshot v1, https://goo.gl/fbAQLP

exports[`Number basic 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj0(path, value, context) {
    if (typeof value === 'string') {
        value = Number(value);
    }
    if (typeof value !== 'number' || Number.isNaN(value)) {
        return new ValidationError(path, 'expected a number');
    }
    return value;
}"
`;

exports[`Number maximum 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj0(path, value, context) {
    if (typeof value === 'string') {
        value = Number(value);
    }
    if (typeof value !== 'number' || Number.isNaN(value)) {
        return new ValidationError(path, 'expected a number');
    }
    if (value > 10) {
        return new ValidationError(path, 'value greater than maximum');
    }
    return value;
}"
`;

exports[`Number maximum exclusiveMaximum 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj0(path, value, context) {
    if (typeof value === 'string') {
        value = Number(value);
    }
    if (typeof value !== 'number' || Number.isNaN(value)) {
        return new ValidationError(path, 'expected a number');
    }
    if (value >= 10) {
        return new ValidationError(path, 'value greater than maximum');
    }
    return value;
}"
`;

exports[`Number minimum 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj0(path, value, context) {
    if (typeof value === 'string') {
        value = Number(value);
    }
    if (typeof value !== 'number' || Number.isNaN(value)) {
        return new ValidationError(path, 'expected a number');
    }
    if (value < 10) {
        return new ValidationError(path, 'value less than minimum');
    }
    return value;
}"
`;

exports[`Number minimim exclusiveMinimum 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj0(path, value, context) {
    if (typeof value === 'string') {
        value = Number(value);
    }
    if (typeof value !== 'number' || Number.isNaN(value)) {
        return new ValidationError(path, 'expected a number');
    }
    if (value <= 10) {
        return new ValidationError(path, 'value less than minimum');
    }
    return value;
}"
`;

exports[`Integer basic 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj0(path, value, context) {
    if (typeof value === 'string') {
        value = Number(value);
    }
    if (typeof value !== 'number' || Number.isNaN(value)) {
        return new ValidationError(path, 'expected a number');
    }
    return value;
}"
`;

exports[`Nullable nullable: true 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj0(path, value, context) {
    if (value === null) {
        return value;
    }
    if (typeof value === 'string') {
        value = Number(value);
    }
    if (typeof value !== 'number' || Number.isNaN(value)) {
        return new ValidationError(path, 'expected a number');
    }
    return value;
}"
`;

exports[`String with enum 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj0(path, value, context) {
    if (value !== 'a' && value !== 'b' && value !== 'c') {
        return new ValidationError(path, 'expected one of the enum value');
    }
    return value;
}"
`;

exports[`String with pattern 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
const obj1 = new RegExp('^[a-z]+$');
function obj0(path, value, context) {
    if (typeof value !== 'string') {
        return new ValidationError(path, 'expected a string');
    }
    if (!obj1.test(value)) {
        return new ValidationError(path, 'expected to match the pattern "^[a-z]+$"');
    }
    return value;
}"
`;

exports[`String with pattern 2`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj0(path, value, context) {
    if (typeof value !== 'string') {
        return new ValidationError(path, 'expected a string');
    }
    const formatResult = context?.stringFormats?.['uri']?.(value, path);
    if (formatResult instanceof ValidationError) {
        return formatResult;
    }
    return value;
}"
`;

exports[`Objects with a required prop 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj1(path, value, context) {
    if (typeof value === 'string') {
        value = Number(value);
    }
    if (typeof value !== 'number' || Number.isNaN(value)) {
        return new ValidationError(path, 'expected a number');
    }
    return value;
}
function obj2(path, value, context) {
    if (typeof value !== 'string') {
        return new ValidationError(path, 'expected a string');
    }
    return value;
}
function obj0(path, value, context) {
    if (typeof value !== 'object' || value === null) {
        return new ValidationError(path, 'expected an object');
    }
    const keys = new Set(Object.keys(value));
    const value0 = value['foo'];
    if (value0 !== undefined) {
        const result0 = obj1([
            ...path,
            'foo'
        ], value0, context);
        if (result0 instanceof ValidationError) {
            return result0;
        }
        value['foo'] = result0;
        keys.delete('foo');
    } else {
        return new ValidationError(path, 'expected "foo" to be defined');
    }
    const value1 = value['bar'];
    if (value1 !== undefined) {
        const result1 = obj2([
            ...path,
            'bar'
        ], value1, context);
        if (result1 instanceof ValidationError) {
            return result1;
        }
        value['bar'] = result1;
        keys.delete('bar');
    }
    return value;
}"
`;

exports[`Objects with a default value 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj1(path, value, context) {
    if (typeof value === 'string') {
        value = Number(value);
    }
    if (typeof value !== 'number' || Number.isNaN(value)) {
        return new ValidationError(path, 'expected a number');
    }
    return value;
}
function obj0(path, value, context) {
    if (typeof value !== 'object' || value === null) {
        return new ValidationError(path, 'expected an object');
    }
    const keys = new Set(Object.keys(value));
    const value0 = value['foo'];
    if (value0 !== undefined) {
        const result0 = obj1([
            ...path,
            'foo'
        ], value0, context);
        if (result0 instanceof ValidationError) {
            return result0;
        }
        value['foo'] = result0;
        keys.delete('foo');
    } else {
        value['foo'] = 10;
    }
    return value;
}"
`;

exports[`Objects as free form object 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj0(path, value, context) {
    if (typeof value !== 'object' || value === null) {
        return new ValidationError(path, 'expected an object');
    }
    const keys = new Set(Object.keys(value));
    return value;
}"
`;

exports[`Objects with additionalProperties: true 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj1(path, value, context) {
    if (typeof value === 'string') {
        value = Number(value);
    }
    if (typeof value !== 'number' || Number.isNaN(value)) {
        return new ValidationError(path, 'expected a number');
    }
    return value;
}
function obj0(path, value, context) {
    if (typeof value !== 'object' || value === null) {
        return new ValidationError(path, 'expected an object');
    }
    const keys = new Set(Object.keys(value));
    const value0 = value['foo'];
    if (value0 !== undefined) {
        const result0 = obj1([
            ...path,
            'foo'
        ], value0, context);
        if (result0 instanceof ValidationError) {
            return result0;
        }
        value['foo'] = result0;
        keys.delete('foo');
    } else {
        value['foo'] = 10;
    }
    return value;
}"
`;

exports[`Objects with additionalProperties: {} 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj1(path, value, context) {
    if (typeof value === 'string') {
        value = Number(value);
    }
    if (typeof value !== 'number' || Number.isNaN(value)) {
        return new ValidationError(path, 'expected a number');
    }
    return value;
}
function obj2(path, value, context) {
    if (typeof value !== 'string') {
        return new ValidationError(path, 'expected a string');
    }
    return value;
}
function obj0(path, value, context) {
    if (typeof value !== 'object' || value === null) {
        return new ValidationError(path, 'expected an object');
    }
    const keys = new Set(Object.keys(value));
    const value0 = value['foo'];
    if (value0 !== undefined) {
        const result0 = obj1([
            ...path,
            'foo'
        ], value0, context);
        if (result0 instanceof ValidationError) {
            return result0;
        }
        value['foo'] = result0;
        keys.delete('foo');
    } else {
        value['foo'] = 10;
    }
    for (const key of keys) {
        const result = obj2([
            ...path,
            key
        ], value[key], context);
        if (result instanceof ValidationError) {
            return result;
        }
        value[key] = result;
    }
    return value;
}"
`;

exports[`Objects with minProperties/maxProperties 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj0(path, value, context) {
    if (typeof value !== 'object' || value === null) {
        return new ValidationError(path, 'expected an object');
    }
    const keys = new Set(Object.keys(value));
    if (keys.size < 1) {
        return new ValidationError(path, 'expected at least 1 properties');
    }
    if (keys.size > 10) {
        return new ValidationError(path, 'expected at most 10 properties');
    }
    return value;
}"
`;

exports[`Array minItems / maxItems 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj1(path, value, context) {
    if (typeof value !== 'string') {
        return new ValidationError(path, 'expected a string');
    }
    return value;
}
function obj0(path, value, context) {
    if (!Array.isArray(value)) {
        return new ValidationError(path, 'expected an array');
    }
    if (value.length < 1) {
        return new ValidationError(path, 'expected at least 1 items');
    }
    if (value.length > 10) {
        return new ValidationError(path, 'expected at most 10 items');
    }
    for (let i = 0; i < value.length; i++) {
        const itemResult = obj1([
            ...path,
            i
        ], value[i], context);
        if (itemResult instanceof ValidationError) {
            return itemResult;
        }
        value[i] = itemResult;
    }
    return value;
}"
`;

exports[`Array uniqueItems 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj1(path, value, context) {
    if (typeof value !== 'string') {
        return new ValidationError(path, 'expected a string');
    }
    return value;
}
function obj0(path, value, context) {
    if (!Array.isArray(value)) {
        return new ValidationError(path, 'expected an array');
    }
    const valueSet = new Set();
    for (let i = 0; i < value.length; i++) {
        const itemResult = obj1([
            ...path,
            i
        ], value[i], context);
        if (valueSet.has(itemResult)) {
            return new ValidationError(path, 'expected unique items');
        }
        valueSet.add(itemResult);
        if (itemResult instanceof ValidationError) {
            return itemResult;
        }
        value[i] = itemResult;
    }
    return value;
}"
`;

exports[`anyOf 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj1(path, value, context) {
    if (typeof value === 'string') {
        value = Number(value);
    }
    if (typeof value !== 'number' || Number.isNaN(value)) {
        return new ValidationError(path, 'expected a number');
    }
    return value;
}
function obj2(path, value, context) {
    if (typeof value !== 'string') {
        return new ValidationError(path, 'expected a string');
    }
    return value;
}
function obj0(path, value, context) {
    const value0 = obj1(path, value, context);
    if (!(value0 instanceof ValidationError)) {
        return value0;
    }
    const value1 = obj2(path, value, context);
    if (!(value1 instanceof ValidationError)) {
        return value1;
    }
    return new ValidationError(path, 'expected one of the anyOf schemas to match');
}"
`;

exports[`oneOf 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj1(path, value, context) {
    if (typeof value === 'string') {
        value = Number(value);
    }
    if (typeof value !== 'number' || Number.isNaN(value)) {
        return new ValidationError(path, 'expected a number');
    }
    return value;
}
function obj2(path, value, context) {
    if (typeof value !== 'string') {
        return new ValidationError(path, 'expected a string');
    }
    return value;
}
function obj0(path, value, context) {
    let result;
    const alt0 = obj1(path, value, context);
    if (!(alt0 instanceof ValidationError)) {
        result = alt0;
    }
    const alt1 = obj2(path, value, context);
    if (!(alt1 instanceof ValidationError)) {
        if (result !== undefined) {
            return new ValidationError(path, 'expected to only match one of the schemas');
        }
        result = alt1;
    }
    if (result === undefined) {
        return new ValidationError(path, 'expected to match one');
    }
    return result;
}"
`;

exports[`allOf 1`] = `
"/** 
Validate a request against the OpenAPI spec
@param {{ method: string; path: string; body?: any; query: Record<string, string>; headers: Record<string, string>; }} request - Input request to validate
@param {{ stringFormats?: { [format: string]: (value: string, path: string[]) => ValidationError | null } }} [context] - Context object to pass to validation functions
@returns {{ operationId?: string; params: Record<string, string>; query: Record<string, string>; body?: any; headers: Record<string, string>; }}
*/
export function validateRequest(request, context) {
    return new RequestError(404, 'no operation match path');
}
export class RequestError extends Error {
    /** @param {number} code HTTP code for the error
@param {string} message The error message*/
    constructor(code, message) {
        super(message);
        /** @type {number} HTTP code for the error*/
        this.code = code;
    }
}
export class ValidationError extends RequestError {
    /** @param {string[]} path The path that failed validation
@param {string} message The error message*/
    constructor(path, message) {
        super(409, message);
        /** @type {string[]} The path that failed validation*/
        this.path = path;
    }
}
function obj2(path, value, context) {
    if (typeof value === 'string') {
        value = Number(value);
    }
    if (typeof value !== 'number' || Number.isNaN(value)) {
        return new ValidationError(path, 'expected a number');
    }
    return value;
}
function obj1(path, value, context) {
    if (typeof value !== 'object' || value === null) {
        return new ValidationError(path, 'expected an object');
    }
    const keys = new Set(Object.keys(value));
    const value0 = value['a'];
    if (value0 !== undefined) {
        const result0 = obj2([
            ...path,
            'a'
        ], value0, context);
        if (result0 instanceof ValidationError) {
            return result0;
        }
        value['a'] = result0;
        keys.delete('a');
    }
    return value;
}
function obj4(path, value, context) {
    if (typeof value !== 'string') {
        return new ValidationError(path, 'expected a string');
    }
    return value;
}
function obj3(path, value, context) {
    if (typeof value !== 'object' || value === null) {
        return new ValidationError(path, 'expected an object');
    }
    const keys = new Set(Object.keys(value));
    const value0 = value['b'];
    if (value0 !== undefined) {
        const result0 = obj4([
            ...path,
            'b'
        ], value0, context);
        if (result0 instanceof ValidationError) {
            return result0;
        }
        value['b'] = result0;
        keys.delete('b');
    }
    return value;
}
function obj0(path, value, context) {
    let result = value;
    result = obj1(path, result, context);
    if (result instanceof ValidationError) {
        return result;
    }
    result = obj3(path, result, context);
    if (result instanceof ValidationError) {
        return result;
    }
    return result;
}"
`;
